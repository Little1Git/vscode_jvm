安装
基本类型-包装类
String
List-Set-Map
循环
异常捕获

Stream

堆-栈-内存
性能

JDk: javac(编译器) + JVM(虚拟机) + JRE(运行环境) + jar(打包工具) + 类库

Java Virtual Machine (JVM)
是运行Java程序的虚拟机
JVM将Java字节码转换为机器码并执行

堆（Heap）
JVM用Heap来存放 对象实例 和 数组,  所有线程共享一个堆。
需要通过对象引用（指针）间接访问内存地址
堆内存由垃圾收集器（Garbage Collector）来管理

新生代（Young Generation 1/3）: 
存放新创建的对象 ， JVM垃圾回收频率高

老年代（Old Generation 2/3）: 
存放长期存活的对象。当对象在新生代存活足够多次后，
会被移动到老年代。大对象直接分配到老年代

堆内存不足OutOfMemoryError
当 JVM 启动时，存在初始堆大小
堆内存通常会有一定的空闲空间
可以自动扩容，但受到最大堆大小限制

栈（JVM Stack）
栈是运行时的单位，用于管理方法调用和执行, 栈是线程私有的
保存方法的局部变量（8 种基本数据类型、对象的引用地址）

每个线程在运行时都有一个独立的虚拟机栈，
每个方法调用都会在栈中创建一个栈帧（Stack Frame）。

栈的存取速度非常快，因为它遵循后进先出（LIFO）的原则，分配和释放内存都在栈顶进行，效率高。
栈的内存管理不需要垃圾回收，因为栈帧随着方法的调用和返回自动分配和释放。
栈内存不足StackOverflowError
固定大小，不会自动扩展。

默认最大堆大小是物理内存大小的1/4
默认栈大小1MB

JVM 在启动时会向操作系统申请一块较大的内存区域，用作 Java 堆（heap）。
这块内存区域会被分配给 JVM 用于管理对象的创建和垃圾回收。


代码原则:
	减少创建对象的数量
	减少使用全局变量和大对象

需要进行JVM调优情况：

    Full GC 次数频繁；(老年代（Old Generation）空间不足)
    GC 停顿时间 > 1秒；(新生代空间不足)
    出现OutOfMemory异常；

JVM调优量化目标
  Heap 内存使用率 <= 70%;
  Old generation内存使用率<= 70%;


GC 的执行会导致应用程序线程暂停，直到垃圾回收过程完成。这个暂停时间称为 "GC 暂停"。
avgpause 表示在垃圾回收过程中，应用程序平均暂停的时间。这是一个关键的性能指标












-Xms：初始堆大小。
-Xmx：最大堆大小。
-XX:MinHeapFreeRatio 和 -XX:MaxHeapFreeRatio：控制堆的空闲比例，帮助 JVM 决定何时扩展或缩小堆。

在win11平台


